import fs from 'fs/promises';
import path from 'path';
import chalk from 'chalk';
import type { UserStoryRequirements, TestCase } from '../core/types.js';

/**
 * Test Prompt Manager - Handles storing and reading generated test prompts
 */
export class TestPromptManager {
  private outputsDir: string;
  private requirementsDir: string;
  private testCasesDir: string;
  private testResultsDir: string;

  constructor(baseDir: string = 'outputs') {
    this.outputsDir = baseDir;
    this.requirementsDir = path.join(baseDir, 'requirements');
    this.testCasesDir = path.join(baseDir, 'test-cases');
    this.testResultsDir = path.join(baseDir, 'test-results');
  }

  /**
   * Initialize the output directories
   */
  async initialize(): Promise<void> {
    try {
      await this.ensureDirectoryExists(this.outputsDir);
      await this.ensureDirectoryExists(this.requirementsDir);
      await this.ensureDirectoryExists(this.testCasesDir);
      await this.ensureDirectoryExists(this.testResultsDir);
      
      console.log(chalk.green('‚úÖ Output directories initialized'));
    } catch (error) {
      console.error(chalk.red('‚ùå Failed to initialize output directories:'), error);
    }
  }

  /**
   * Safely create directory if it doesn't exist
   */
  private async ensureDirectoryExists(dirPath: string): Promise<void> {
    try {
      await fs.mkdir(dirPath, { recursive: true });
    } catch (error: any) {
      // Ignore EEXIST errors - directory already exists
      if (error.code !== 'EEXIST') {
        throw error;
      }
    }
  }

  /**
   * Saves Story Analyst output as a requirements prompt file
   * @param storyId - Unique identifier for the story
   * @param userStory - Original user story
   * @param requirements - Analyzed requirements from Story Analyst
   */
  async saveRequirementsPrompt(
    storyId: string,
    storyModule: string,
    userStory: string, 
    requirements: UserStoryRequirements
  ): Promise<string> {
    // Create module directory if it doesn't exist
    const moduleDir = path.join(this.requirementsDir, storyModule);
    await this.ensureDirectoryExists(moduleDir);
    
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const fileName = `${storyId}-requirements-${timestamp}.md`;
    const filePath = path.join(moduleDir, fileName);
    
    const promptContent = `# Story Analysis Results

## Original User Story
\`\`\`
${userStory}
\`\`\`

## Analyzed Requirements (Story Analyst Agent Output)

### Feature
${requirements.feature}

### User Actions
${requirements.actions.map(action => `- ${action}`).join('\n')}

### Expected Outcomes
${requirements.outcomes.map(outcome => `- ${outcome}`).join('\n')}

### Edge Cases
${requirements.edgeCases.map(edge => `- ${edge}`).join('\n')}

### Acceptance Criteria
${requirements.acceptanceCriteria.map(criteria => `- ${criteria}`).join('\n')}

## JSON Output
\`\`\`json
${JSON.stringify(requirements, null, 2)}
\`\`\`

---
*Generated by Story Analyst Agent on ${new Date().toISOString()}*
`;

    try {
      await fs.writeFile(filePath, promptContent, 'utf-8');
      console.log(chalk.green(`üíæ Requirements saved: ${fileName}`));
      return filePath;
    } catch (error) {
      console.error(chalk.red('‚ùå Failed to save requirements prompt:'), error);
      throw error;
    }
  }



  /**
   * Reads test cases from a prompt file for Test Executor
   * @param filePath - Path to the test cases prompt file
   * @returns Array of test cases
   */
  async loadTestCasesFromPrompt(filePath: string): Promise<TestCase[]> {
    try {
      const content = await fs.readFile(filePath, 'utf-8');
      
      // Look for the "Complete JSON Output for Test Executor" section
      const executorSectionMatch = content.match(/## Complete JSON Output for Test Executor\s*```json\s*([\s\S]*?)\s*```/);
      
      if (executorSectionMatch) {
        // Use the JSON from the Test Executor section
        const jsonContent = executorSectionMatch[1].trim();
        const testCases = JSON.parse(jsonContent) as TestCase[];
        console.log(chalk.blue(`üìñ Loaded ${testCases.length} test cases from: ${path.basename(filePath)}`));
        return testCases;
      }
      
      // Fallback: Look for any JSON block containing test cases
      const jsonBlocks = content.match(/```json\s*([\s\S]*?)\s*```/g);
      
      if (!jsonBlocks || jsonBlocks.length === 0) {
        throw new Error('No JSON test cases found in prompt file');
      }
      
      // Try each JSON block until we find valid test cases
      for (const block of jsonBlocks) {
        try {
          const jsonContent = block.replace(/```json\s*/, '').replace(/\s*```/, '').trim();
          const parsed = JSON.parse(jsonContent);
          
          // Check if it's an array of test cases
          if (Array.isArray(parsed) && parsed.length > 0 && parsed[0].testName) {
            const testCases = parsed as TestCase[];
            console.log(chalk.blue(`üìñ Loaded ${testCases.length} test cases from: ${path.basename(filePath)}`));
            return testCases;
          }
        } catch (parseError) {
          // Continue to next JSON block
          continue;
        }
      }
      
      throw new Error('No valid test cases array found in any JSON block');
      
    } catch (error) {
      console.error(chalk.red('‚ùå Failed to load test cases from prompt:'), error);
      console.error(chalk.gray(`File: ${filePath}`));
      
      // Return fallback test case to prevent complete failure
      console.log(chalk.yellow('‚ö†Ô∏è Using fallback test case due to parsing error'));
      return [
        {
          testName: 'Fallback test case',
          steps: ['Navigate to application', 'Perform basic action', 'Verify result'],
          assertions: ['Application responds correctly'],
          testData: {},
          priority: 'medium'
        }
      ];
    }
  }





  /**
   * Generates a story ID from user story content
   * @param userStory - User story text
   */
  generateStoryId(userStory: string): string {
    // Extract the main action from "As a user, I want to..."
    const match = userStory.match(/As a.*?I want to\s+([^\.]+)/i);
    let action = match ? match[1] : 'test';
    
    return action
      .toLowerCase()
      .replace(/[^a-z0-9\s]/g, '')
      .replace(/\s+/g, '-')
      .substring(0, 30);
  }



  /**
   * Save test cases to organized modular structure by story module
   * @param storyId - The user story ID
   * @param storyModule - The module (e.g., 'authentication', 'account-management')
   * @param requirements - Analyzed requirements from Story Analyst
   * @param testCases - Generated test cases from Test Generator
   */
  async saveOrganizedTestCases(
    storyId: string,
    storyModule: string,
    requirements: UserStoryRequirements,
    testCases: TestCase[]
  ): Promise<string> {
    // Create module directory if it doesn't exist
    const moduleDir = path.join(this.testCasesDir, storyModule);
    await this.ensureDirectoryExists(moduleDir);
    
    const fileName = `${storyId}-tests.md`;
    const filePath = path.join(moduleDir, fileName);
    
    const organizedContent = `# ${storyModule.toUpperCase()} Module Test Cases

## Story: ${storyId}
**Feature:** ${requirements.feature}  
**Module:** ${storyModule}  
**Generated:** ${new Date().toISOString().split('T')[0]}

## Test Suite Summary
- **Total Test Cases:** ${testCases.length}
- **High Priority:** ${testCases.filter(tc => tc.priority === 'high').length}
- **Medium Priority:** ${testCases.filter(tc => tc.priority === 'medium').length}
- **Low Priority:** ${testCases.filter(tc => tc.priority === 'low').length}

## Requirements Analysis
**Actions:** ${requirements.actions.join(', ')}  
**Outcomes:** ${requirements.outcomes.join(', ')}  
**Edge Cases:** ${requirements.edgeCases.join(', ')}

## Generated Test Cases

${testCases.map((testCase, index) => `
### Test Case ${index + 1}: ${testCase.testName}
**Priority:** ${testCase.priority.toUpperCase()}

#### Test Steps:
${testCase.steps.map((step, i) => `${i + 1}. ${step}`).join('\n')}

#### Assertions:
${(testCase.assertions || []).map(assertion => `- ${assertion}`).join('\n') || '- Validations are embedded in test steps with EXPECT markers'}

#### Test Data:
\`\`\`json
${JSON.stringify(testCase.testData || {}, null, 2)}
\`\`\`

---
`).join('\n')}

## Automation-Ready JSON
\`\`\`json
{
  "module": "${storyModule}",
  "storyId": "${storyId}",
  "testSuite": "${requirements.feature} Tests",
  "testCases": ${JSON.stringify(testCases, null, 2)}
}
\`\`\`

---
*Generated by Multi-Agent Test Automation Framework on ${new Date().toISOString()}*
`;

    try {
      await fs.writeFile(filePath, organizedContent, 'utf-8');
      console.log(chalk.cyan(`üìÅ Organized test cases saved: ${storyModule}/${fileName}`));
      return filePath;
    } catch (error) {
      console.error(chalk.red('‚ùå Failed to save organized test cases:'), error);
      throw error;
    }
  }

  /**
   * Save test results in organized structure as both JSON and HTML
   * @param storyId - Unique identifier for the story
   * @param storyModule - Module name for organization
   * @param results - Test execution results
   * @param htmlContent - Optional HTML report content
   */
  async saveTestResults(
    storyId: string,
    storyModule: string,
    results: any[],
    htmlContent?: string
  ): Promise<string> {
    // Create module directory if it doesn't exist
    const moduleDir = path.join(this.testResultsDir, storyModule);
    await this.ensureDirectoryExists(moduleDir);
    
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    
    try {
      // Save JSON results
      const jsonFileName = `${storyId}-results-${timestamp}.json`;
      const jsonFilePath = path.join(moduleDir, jsonFileName);
      await fs.writeFile(jsonFilePath, JSON.stringify(results, null, 2), 'utf-8');
      
      // Save HTML results if provided
      if (htmlContent) {
        const htmlFileName = `${storyId}-results-${timestamp}.html`;
        const htmlFilePath = path.join(moduleDir, htmlFileName);
        await fs.writeFile(htmlFilePath, htmlContent, 'utf-8');
        
        console.log(chalk.blue(`üìä Test results saved:`));
        console.log(chalk.gray(`   JSON: ${storyModule}/${jsonFileName}`));
        console.log(chalk.green(`   HTML: ${storyModule}/${htmlFileName} üåê`));
        console.log(chalk.cyan(`   üëÄ Open in browser: file://${htmlFilePath.replace(/\\/g, '/')}`));
        
        return htmlFilePath;
      } else {
        console.log(chalk.blue(`üìä Test results saved: ${storyModule}/${jsonFileName}`));
        return jsonFilePath;
      }
    } catch (error) {
      console.error(chalk.red('‚ùå Failed to save test results:'), error);
      throw error;
    }
  }
}
